// stack: [ top bottom ]

// runtime encoding:
// {runtime_code} {32 byte threshold} {32 byte domain_separator} {address[] signers}
// signers array is non-standard encoding, without offset to data
// that is:
// 0-32: len(signers)
// 32-64: first element of signers array, right-aligned

// --- Constants ---
// [] -> [ constant ]

/// Function signatures
#define macro PUSH_EXEC_FUNC_SIG = takes(0) returns(1) { 0xb0fddf53 }
#define macro PUSH_SIGNERS_FUNC_SIG = takes(0) returns(1) { 0x43761ca7 }
#define macro PUSH_THRESHOLD_FUNC_SIG = takes(0) returns(1) { 0x42cde4e8 }
#define macro PUSH_DOMSEP_FUNC_SIG = takes(0) returns(1) { 0x3644e515 }

/// EIP-712
// keccak256("Execute(uint8 callType,address target,uint256 value,uint256 expiryBlock,bytes data)");
#define macro PUSH_EXEC_TYPEHASH = takes(0) returns(1) { 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff }

// --- Utils ---

// [ mem_ost ] -> []
template <data_ost>
#define macro CODECOPY_TO_END = takes(1) returns(0) {
  <data_ost> dup1 codesize sub swap2 // [ mem_ost (codesize - data_ost) data_ost ]
  // codecopy(dstOst, ost, len)
  // [ mem_ost data_ost (codesize - data_ost) ]
  codecopy  // []
}

// [ mem_ost len ] -> []
template <data_ost>
#define macro CODECOPY_BY_LEN = takes(1) returns(0) {
  <data_ost>  // [ data_ost mem_ost len  ]
  swap1
  // codecopy(dstOst, ost, len)
  // [ mem_ost data_ost len ]
  codecopy  // []
}

// --- Pure Functions ---

// TODO: note that threshold is encoded as single byte
// [ 00 ] -> return
template <rt_len>
#define macro RET_THRESHOLD = takes(1) returns(0) {
  0x20 dup1 dup3 CODECOPY_BY_LEN<rt_len>()  // [ 32 00 ]
  swap1 return
}

// [ 00 ] -> return
template <rt_len>
#define macro RET_DOMSEP = takes(1) returns(0) {
  0x20 dup1 dup3 CODECOPY_BY_LEN<rt_len+32>()  // [ 0x20 00 ]
  swap1 return
}

// note that addresses are encoded in 32 bytes, right-aligned
// [ 00 ] -> return
template <rt_len>
#define macro RET_SIGNERS = takes(1) returns(0) {
  // mstore(0x00, 0x20) -- store ost to first element of signers array
  0x20 dup1 dup3 mstore  // [ 0x20 00 ]
  // copy signers array len + elements to 0x20 in memory
  dup1 CODECOPY_TO_END<rt_len+64>() // [ 0x20 00 ]
  dup1 mload // [ len(signers) 0x20 00 ]
  mul 0x40 add swap1 // [ 00 (64 + (32 * len(signers))) ]
  // return(ost, len)
  return
}

// --- Execute ---

// [ 00 ] -> return
template <throw_dst, stop_dst, rt_len>
#define macro EXEC = takes(0) returns(0) {
  // mem
    //                  00  {32 byte threshold}
    //                  20  {32 byte domain_sep}
    //                  40  {32 byte len(signers)}
    // 60 : 60+32*(arr_len) elements of signers array
  // calldata
    // {4 byte sig}
    // {32 byte callType}{32 byte txGas}{32 byte value}{32 byte target}
    // {data}{sigs}

  // todo: check size of calldata

  // copy all appended data into mem
  // dup1 CODECOPY_TO_END<rt_len>() // [ 00 ]
  // dup1 mload  0xf8 shr // [ threshold 00 ]
  // 0x01 mload  // [ dom_sep threshold 00 ]
  // 0x21 mload  // [ len(signers) dom_sep threshold 00 ]
  // 0x04 calldataload // [ call_type len(signers) dom_sep threshold 00 ]
  // 0x24 calldataload // [ target call_type len(signers) dom_sep threshold 00 ]
  // 0x44 calldataload // [ val target call_type len(signers) dom_sep threshold 00 ]
  // 0x64 calldataload // [ expiryBlock val target call_type len(signers) dom_sep threshold 00 ]
}

// --- Control Flow ---

// [ 00 ] -> []
template <pure_funcs_dst>
#define macro DISPATCH = takes(1) returns(0) {
  calldataload 0xe0 shr dup1  // [ calldata[:4] calldata[:4] ]
  PUSH_EXEC_FUNC_SIG() eq iszero  // [ (calldata[:4] != execute_sig) calldata[:4] ]
  <pure_funcs_dst> jumpi // jumps to pure_func dispatcher with func sig on stack
  pop // []
}

// [ calldata[:4] 00 ] -> return
template <throw_dst, stop_dst, rt_len>
#define macro DISPATCH_PURE_FUNCS = takes(1) returns(0) {

  // (payable receive function)
  // if calldatasize == 0, jump to stop
  calldatasize iszero <stop_dst> jumpi  // [ calldata[:4] 00 ]

  // require(callvalue == 0 && calldatasize == 4)
  callvalue iszero calldatasize 0x04 eq // [ (calldatasize == 4) (callvalue == 0) calldata[:4] 00 ]
  and iszero <throw_dst> jumpi // [ calldata[:4] 00 ]

  swap1 dup2 // [ calldata[:4] 00 calldata[:4] ]
  // todo:
  PUSH_THRESHOLD_FUNC_SIG() eq threshold_dst jumpi // [ 00 calldata[:4] ]
  dup2 PUSH_DOMSEP_FUNC_SIG() eq dom_sep_dst jumpi // [ 00 calldata[:4] ]
  swap1 PUSH_SIGNERS_FUNC_SIG() eq signers_dst jumpi // [ 00 ]
  <throw_dst> jump  // revert if we have non-empty calldata but no matches todo: replace with in-place revert?

  threshold_dst:
    RET_THRESHOLD<rt_len>()
  dom_sep_dst:
    RET_DOMSEP<rt_len>()
  signers_dst:
    RET_SIGNERS<rt_len>()
}


// --- Main ---

// instead of regular dispatcher, we run execute by default, and if
// calldata[:4] != execute, jump past it to view functions
// [] -> []
template <rt_len>
#define macro RUNTIME = takes(0) returns(0) {
  0x00 dup1
  DISPATCH<pure_funcs_dst>()
  EXEC<throw_dst, stop_dst, rt_len>()

  pure_funcs_dst:
    DISPATCH_PURE_FUNCS<throw_dst, stop_dst, rt_len>()

  throw_dst:
    0x00 dup1 revert

  stop_dst:
    stop

  // constructor data
}

